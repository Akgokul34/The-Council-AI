import json
import time
import logging
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.memory import InMemoryMemoryService
from google.adk.plugins.logging_plugin import LoggingPlugin
from google.genai import types

from .agents import root_agent, execution_squad
from .models import QueryRequest, BoardResponse
from .utils import generate_decision_graph

app = FastAPI(title="The Council AI - Board of Directors")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Services
session_service = InMemorySessionService()
memory_service = InMemoryMemoryService()

runner = Runner(
    agent=root_agent,
    app_name="BoardOfDirectorsApp",
    session_service=session_service,
    memory_service=memory_service,
    plugins=[LoggingPlugin()]
)

runner_execution = Runner(
    agent=execution_squad,
    app_name="ExecutionSquadApp",
    session_service=session_service,
    memory_service=memory_service,
    plugins=[LoggingPlugin()]
)

@app.post("/api/v1/board/run", response_model=BoardResponse)
async def run_board(request: QueryRequest):
    try:
        session_id = f"board_{int(time.time())}"
        # Create session
        await session_service.create_session(
            app_name=runner.app_name, 
            user_id="api_user", 
            session_id=session_id
        )
        
        # Prepare input
        content = types.Content(role="user", parts=[types.Part(text=request.query)])
        
        # Run agent
        events = []
        async for event in runner.run_async(
            user_id="api_user", 
            session_id=session_id, 
            new_message=content
        ):
            events.append(event)
            
        # Extract final output
        last_text = None
        for ev in reversed(events):
            if ev.content and ev.content.parts:
                for part in ev.content.parts:
                    if part.text and part.text.strip():
                        last_text = part.text.strip()
                        break
            if last_text:
                break
                
        if not last_text:
            raise HTTPException(status_code=500, detail="No output generated by the board.")
            
        # Parse JSON
        # Clean markdown code blocks if present
        cleaned_text = last_text.strip().replace("```json", "").replace("```", "")
        
        try:
            data = json.loads(cleaned_text)
        except json.JSONDecodeError:
            # Fallback regex extraction could go here
            raise HTTPException(status_code=500, detail="Failed to parse board decision as JSON.")
            
        return BoardResponse(
            executive_summary=data.get("executive_summary", ""),
            strategic_options=data.get("strategic_options", []),
            risks_to_address=data.get("risks_to_address", []),
            final_verdict=data.get("final_verdict", ""),
            raw_output=data
        )

    except Exception as e:
        logging.error(f"Error running board: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/board/visualize")
async def visualize_board(response: BoardResponse):
    """
    Generates a visualization of the board's decision based on the response data.
    Returns a base64 encoded PNG image.
    """
    try:
        # Reconstruct the dictionary expected by the visualizer
        data = response.raw_output or {
            "final_verdict": response.final_verdict
        }
        img_str = generate_decision_graph(data)
        return {"image_base64": img_str}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

from fastapi.responses import StreamingResponse
from .reports import generate_pdf_report

@app.post("/api/v1/board/report")
async def download_report(response: BoardResponse):
    """
    Generates a PDF report of the board's decision.
    """
    try:
        # Convert Pydantic model to dict
        data = response.dict()
        pdf_buffer = generate_pdf_report(data)
        
        return StreamingResponse(
            pdf_buffer,
            media_type="application/pdf",
            headers={"Content-Disposition": "attachment; filename=board_decision_report.pdf"}
        )
    except Exception as e:
        logging.error(f"Report generation error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.websocket("/ws/board")
async def websocket_board(websocket: WebSocket):
    await websocket.accept()
    try:
        # Receive the query
        data = await websocket.receive_text()
        try:
            query_data = json.loads(data)
            query = query_data.get("query")
        except:
            query = data # Handle plain text too

        if not query:
            await websocket.send_text(json.dumps({"type": "error", "message": "No query provided"}))
            return

        session_id = f"board_ws_{int(time.time())}"
        await session_service.create_session(
            app_name=runner.app_name, 
            user_id="ws_user", 
            session_id=session_id
        )
        
        content = types.Content(role="user", parts=[types.Part(text=query)])
        
        async for event in runner.run_async(
            user_id="ws_user", 
            session_id=session_id, 
            new_message=content
        ):
            # Extract text
            text = ""
            if event.content and event.content.parts:
                for part in event.content.parts:
                    if part.text:
                        text += part.text
            
            # Determine agent name (source)
            agent_name = getattr(event, "source", "System")
            
            if text:
                # Send streaming update
                await websocket.send_text(json.dumps({
                    "type": "update",
                    "agent": agent_name,
                    "text": text
                }))
                
        await websocket.send_text(json.dumps({"type": "complete"}))
            
    except WebSocketDisconnect:
        logging.info("WebSocket disconnected")
    except Exception as e:
        logging.error(f"WebSocket error: {e}")
        try:
            await websocket.send_text(json.dumps({"type": "error", "message": str(e)}))
        except:
            pass

@app.websocket("/ws/execution")
async def websocket_execution(websocket: WebSocket):
    await websocket.accept()
    try:
        # Receive the strategic plan (final verdict)
        data = await websocket.receive_text()
        try:
            input_data = json.loads(data)
            plan_context = input_data.get("plan")
        except:
            plan_context = data 

        if not plan_context:
            await websocket.send_text(json.dumps({"type": "error", "message": "No plan context provided"}))
            return

        session_id = f"exec_ws_{int(time.time())}"
        await session_service.create_session(
            app_name=runner_execution.app_name, 
            user_id="ws_user", 
            session_id=session_id
        )
        
        # The Architect needs the context to start
        content = types.Content(role="user", parts=[types.Part(text=f"Here is the strategic plan to implement: {plan_context}")])
        
        async for event in runner_execution.run_async(
            user_id="ws_user", 
            session_id=session_id, 
            new_message=content
        ):
            # Extract text
            text = ""
            if event.content and event.content.parts:
                for part in event.content.parts:
                    if part.text:
                        text += part.text
            
            # Determine agent name (source)
            agent_name = getattr(event, "source", "System")
            
            if text:
                await websocket.send_text(json.dumps({
                    "type": "update",
                    "agent": agent_name,
                    "text": text
                }))
                
        await websocket.send_text(json.dumps({"type": "complete"}))
            
    except WebSocketDisconnect:
        logging.info("Execution WebSocket disconnected")
    except Exception as e:
        logging.error(f"Execution WebSocket error: {e}")
        try:
            await websocket.send_text(json.dumps({"type": "error", "message": str(e)}))
        except:
            pass

# Serve Frontend (Must be last)
import os
from fastapi.staticfiles import StaticFiles

# Check if frontend build exists
frontend_dist = os.path.join(os.path.dirname(os.path.dirname(__file__)), "frontend", "dist")

if os.path.exists(frontend_dist):
    app.mount("/", StaticFiles(directory=frontend_dist, html=True), name="static")
else:
    @app.get("/")
    def read_root():
        return {"message": "The Council AI API is running. Frontend build not found."}
